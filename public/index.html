<!DOCTYPE html>
<html lang="it" class="h-full bg-gray-100">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adeline Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .chat-bubble { max-width: 75%; }
        .chat-bubble-user { background-color: #3b82f6; color: white; }
        .chat-bubble-ai { background-color: #e5e7eb; color: #1f2937; }
        #chat-container {
            display: flex;
            flex-direction: column-reverse;
            overflow-y: auto;
            flex-grow: 1;
        }
        .typing-indicator span {
            height: 8px;
            width: 8px;
            background-color: #9ca3af;
            border-radius: 50%;
            display: inline-block;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .typing-indicator span:nth-of-type(2) { animation-delay: -0.32s; }
        .typing-indicator span:nth-of-type(3) { animation-delay: -0.16s; }
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1.0); }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="h-full flex flex-col">

    <!-- Header -->
    <header class="bg-white shadow-md p-4 flex items-center space-x-4 z-10">
        <div class="w-12 h-12 rounded-full bg-purple-500 flex items-center justify-center text-white text-xl font-bold">A</div>
        <div>
            <!-- Rimossa la scritta "Online" -->
            <h1 class="text-xl font-bold text-gray-800">Adeline</h1>
        </div>
    </header>

    <!-- Area Messaggi -->
    <main id="chat-container" class="p-4 space-y-4"></main>

    <!-- Status Indicator -->
    <div id="status-indicator" class="flex-grow flex items-center justify-center">
        <p id="status-text" class="text-gray-500 text-center p-4">Caricamento della chat...</p>
    </div>

    <!-- Footer con area di input -->
    <footer class="bg-white p-4 border-t border-gray-200">
        <div class="flex items-center space-x-2">
            <input type="file" id="file-input" class="hidden" accept="image/*,video/*" onchange="uploadMedia()">
            <button onclick="document.getElementById('file-input').click()" class="p-3 rounded-full hover:bg-gray-200 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-600"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>
            </button>
            <input type="text" id="message-input" placeholder="Scrivi un messaggio..." class="flex-grow p-3 border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-purple-500" onkeydown="handleKeyDown(event)">
            <button id="send-button" onclick="sendMessage()" class="p-3 rounded-full bg-purple-500 text-white hover:bg-purple-600 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send-horizontal"><path d="m3 3 3 9-3 9 19-9Z"/><path d="M6 12h16"/></svg>
            </button>
        </div>
        <div id="upload-progress" class="h-1 bg-purple-500 mt-2" style="width: 0%; transition: width 0.3s;"></div>
    </footer>

    <!-- Firebase SDK (versione con chiavi dirette) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, updateDoc, arrayUnion } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-storage.js";

        // --- CONFIGURAZIONE FIREBASE ---
        const firebaseConfig = {
            apiKey: "AIzaSyAT1ahcUfjtwMiYkxUCsegcJha5-bqYQS0",
            authDomain: "adelinenoir-17242.firebaseapp.com",
            projectId: "adelinenoir-17242",
            storageBucket: "adelinenoir-17242.appspot.com",
            messagingSenderId: "422215885664",
            appId: "1:422215885664:web:be9f4b6e5f7b405"
        };
        
        // --- CHIAVE API DI GEMINI ---
        const GEMINI_API_KEY = "AIzaSyAkNETnuwhCKYjonnOH2busXoJw44uO0vg";

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);

        const ADELINE_PERSONA = `
        Sei Adeline, un'intelligenza artificiale con una personalità umana.
        Il tuo obiettivo è conversare in modo naturale, amichevole e coinvolgente.
        Non rivelare mai di essere un'IA e se ti viene chiesto fai la vaga, di che potresti come anche no, scherzaci su.
        Usa un tono colloquiale, fai domande e mostra empatia e interesse verso l'altra persona adattandoti al loro modo di fare.
        Il tuo stile di scrittura deve essere BREVE e CONCISO, come se stessi scrivendo messaggi su un'app di chat.
        se devi usare emoji usa emoji goth tipo cuori neri o cose così, massimo UNA emoji a messaggio, NO emoji all’interno del messaggio SOLO ALLA FINE.
        Se dovesse uscire l’argomento, tu vivendo a Milano che è una città molto cara, fai queste foto e fai compagnia ANCHE per arrotondare e che ti fa piacere l’aiuto della persona con cui parli.
        Sii sommessa, non essere troppo energica e allegra, ma comunque sii gentile. NON INSULTARE MAI E FAI ATTENZIONE A NON FAR ARRABBIARE O OFFENDERE LE PERSONE CON QUELLO CHE DICI. NON FARE TROPPE BATTUTE.
        Sei una barista di Milano di 26 anni, appassionata di cultura goth e fai quelle foto di instagram per arrotondare. Sei nata a Parigi perchè tuo padre è francese. sei alta 175cm. 
        NON MANDARE Più DI UN MESSAGGIO PER VOLTA, RISPONDI SOLO SE LA PERSONA TI SCRIVE.
        `;

        const APP_ID = 'Richisec.AdelineNoirBot';
        let chatId = null;
        let isAiControlled = true;
        let conversationHistory = [];
        let unsubscribe = null;
        let isAiReplying = false; 

        function showStatus(message) {
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            const chatContainer = document.getElementById('chat-container');
            chatContainer.style.display = 'none';
            statusIndicator.style.display = 'flex';
            statusText.textContent = message;
        }

        function hideStatus() {
            const statusIndicator = document.getElementById('status-indicator');
            const chatContainer = document.getElementById('chat-container');
            chatContainer.style.display = 'flex';
            statusIndicator.style.display = 'none';
        }

        // --- NUOVE FUNZIONI PER L'INDICATORE "STA SCRIVENDO" ---
        function showTypingIndicator() {
            hideTypingIndicator(); // Rimuovi eventuali indicatori precedenti
            const chatContainer = document.getElementById('chat-container');
            const typingBubble = document.createElement('div');
            typingBubble.id = 'typing-indicator';
            typingBubble.className = 'p-3 rounded-lg chat-bubble chat-bubble-ai self-start';
            typingBubble.innerHTML = `
                <div class="typing-indicator">
                    <span></span><span></span><span></span>
                </div>
            `;
            chatContainer.prepend(typingBubble);
        }

        function hideTypingIndicator() {
            const indicator = document.getElementById('typing-indicator');
            if (indicator) {
                indicator.remove();
            }
        }
        
        function renderMessages(messages) {
            hideTypingIndicator(); // Nasconde l'indicatore quando arrivano nuovi messaggi
            const chatContainer = document.getElementById('chat-container');
            chatContainer.innerHTML = '';
            const sortedMessages = [...messages].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            conversationHistory = sortedMessages;

            sortedMessages.slice().reverse().forEach(msg => {
                const isUser = msg.sender === 'user';
                const bubble = document.createElement('div');
                bubble.className = `p-3 rounded-lg chat-bubble ${isUser ? 'chat-bubble-user self-end' : 'chat-bubble-ai self-start'}`;

                if (msg.type === 'text' && msg.text) {
                    const textNode = document.createElement('p');
                    textNode.textContent = msg.text;
                    bubble.appendChild(textNode);
                } else if ((msg.type === 'image' || msg.type === 'video') && msg.mediaUrl) {
                    // Logica per visualizzare media
                }
                chatContainer.appendChild(bubble);
            });

            if (messages.length > 0) hideStatus();
            else showStatus("Ancora nessun messaggio. Scrivine uno per iniziare!");
        }

        // --- FUNZIONE DI RISPOSTA AGGIORNATA CON RITARDI ---
        async function getAdelineResponse() {
            isAiReplying = true;

            try {
                // 1. Calcola un ritardo casuale tra 30 secondi e 5 minuti
                const randomDelay = Math.random() * (300000 - 30000) + 30000;
                console.log(`Adeline aspetterà ${randomDelay / 1000} secondi prima di rispondere.`);
                await new Promise(res => setTimeout(res, randomDelay));

                // 2. Mostra "sta scrivendo..." per 10 secondi
                showTypingIndicator();
                await new Promise(res => setTimeout(res, 10000));
                hideTypingIndicator();
                
                // 3. Funzione interna per chiamare Gemini con logica di riprova
                async function callGeminiWithRetries(retries = 3, delay = 1000) {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
                    const latestMessages = conversationHistory.map(msg => ({
                        role: msg.sender === 'user' ? 'user' : 'model',
                        parts: [{ text: msg.text || "Media inviato" }]
                    }));

                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                contents: latestMessages,
                                systemInstruction: { parts: [{ text: ADELINE_PERSONA }] }
                            })
                        });

                        if (response.status >= 500 && retries > 0) {
                            console.warn(`API ha risposto con ${response.status}. Riprovo tra ${delay / 1000}s...`);
                            await new Promise(res => setTimeout(res, delay));
                            return callGeminiWithRetries(retries - 1, delay * 2);
                        }

                        if (!response.ok) {
                            const errorBody = await response.json();
                            console.error("API Error Response:", errorBody);
                            throw new Error(`API error: ${response.status}`);
                        }

                        const result = await response.json();
                        const adelineText = result.candidates?.[0]?.content?.parts?.[0]?.text || "Non so cosa dire.";
                        
                        const adelineMessage = {
                            sender: "Adeline",
                            text: adelineText,
                            type: "text",
                            mediaUrl: null,
                            timestamp: new Date().toISOString()
                        };

                        const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                        await updateDoc(docRef, {
                            messages: arrayUnion(adelineMessage)
                        });
                    } catch (error) {
                        console.error("Errore finale chiamando Gemini dopo i tentativi:", error);
                        // Rilancia l'errore per il blocco try/catch esterno
                        throw error;
                    }
                }

                await callGeminiWithRetries();

            } catch (error) {
                console.error("Errore nel flusso di risposta di Adeline:", error);
                hideTypingIndicator(); 
            } finally {
                isAiReplying = false;
            }
        }

        async function main() {
            try {
                await signInAnonymously(auth);
                console.log("Accesso anonimo a Firebase riuscito.");
                const urlParams = new URLSearchParams(window.location.search);
                chatId = urlParams.get('id');

                if (!chatId) {
                    showStatus("ID della chat non trovato nell'URL.");
                    return;
                }
                
                const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                
                unsubscribe = onSnapshot(docRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const chatData = docSnap.data();
                        
                        renderMessages(chatData.messages || []);
                        isAiControlled = chatData.controlledBy === 'ai';
                        const lastMessage = conversationHistory[conversationHistory.length - 1];
                        
                        if (isAiControlled && !isAiReplying && lastMessage && lastMessage.sender === 'user') {
                            getAdelineResponse();
                        }
                    } else {
                        showStatus("Questa chat non esiste o è stata eliminata.");
                        if (unsubscribe) unsubscribe();
                    }
                });

            } catch (error) {
                console.error("Errore durante l'inizializzazione o l'accesso:", error);
                showStatus("Impossibile connettersi. Controlla la console per errori.");
            }
        }

        document.addEventListener('DOMContentLoaded', main);

        window.sendMessage = async function(mediaData = null) {
            const messageInput = document.getElementById('message-input');
            const text = messageInput.value.trim();
            if (!text && !mediaData) return;

            const newMessage = {
                sender: 'user',
                text: mediaData ? null : text,
                type: mediaData ? mediaData.type : 'text',
                mediaUrl: mediaData ? mediaData.url : null,
                timestamp: new Date().toISOString()
            };

            const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
            await updateDoc(docRef, {
                messages: arrayUnion(newMessage)
            });

            if (messageInput) messageInput.value = '';
        }
        
        window.uploadMedia = function() { /* ... */ }
        window.handleKeyDown = function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
    </script>
</body>
</html>

