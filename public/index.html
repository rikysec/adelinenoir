<!DOCTYPE html>
<html lang="it" class="h-full bg-gray-100">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adeline Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://js.stripe.com/v3/"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .chat-bubble { max-width: 75%; }
        .chat-bubble-user { background-color: #3b82f6; color: white; }
        .chat-bubble-ai { background-color: #e5e7eb; color: #1f2937; }
        #chat-container { display: flex; flex-direction: column-reverse; overflow-y: auto; flex-grow: 1; }
        #payment-overlay { transition: opacity 0.3s ease-in-out; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="h-full flex flex-col relative">

    <!-- Schermata di Pagamento -->
    <div id="payment-overlay" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50 opacity-0 pointer-events-none">
        <div class="bg-white rounded-lg shadow-xl p-8 max-w-sm w-full text-center">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Chat Interrotta</h2>
            <p class="text-gray-600 mb-6">Funzionalit√† Premium terminata, continua per riaprire la chat e continuare a parlare</p>
            <div id="payment-element" class="mb-6"></div>
            <button id="submit-payment" class="w-full bg-purple-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-purple-700 transition-colors disabled:bg-gray-400">
                <span id="button-text">Paga ora 4,99‚Ç¨</span>
                <span id="spinner" class="hidden">Elaborazione...</span>
            </button>
            <p id="payment-message" class="text-sm text-red-500 mt-4"></p>
        </div>
    </div>

    <!-- Contenuto principale della chat -->
    <div id="main-content" class="h-full flex flex-col">
        <header class="bg-white shadow-md p-4 flex items-center space-x-4 z-10">
            <div class="w-12 h-12 rounded-full bg-purple-500 flex items-center justify-center text-white text-xl font-bold">A</div>
            <div><h1 class="text-xl font-bold text-gray-800">Adeline</h1></div>
        </header>
        <main id="chat-container" class="p-4 space-y-4"></main>
        <div id="status-indicator" class="flex-grow flex items-center justify-center">
            <p id="status-text" class="text-gray-500 text-center p-4">Caricamento della chat...</p>
        </div>
        <div id="typing-indicator" class="p-4 hidden"><p class="text-gray-500 italic">Adeline sta scrivendo...</p></div>
        <footer class="bg-white p-4 border-t border-gray-200">
            <div class="flex items-center space-x-2">
                <input type="file" id="file-input" class="hidden" accept="image/*" onchange="uploadMedia()">
                <button onclick="document.getElementById('file-input').click()" class="p-3 rounded-full hover:bg-gray-200 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-600"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg></button>
                <input type="text" id="message-input" placeholder="Scrivi un messaggio..." class="flex-grow p-3 border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-purple-500" onkeydown="handleKeyDown(event)">
                <button id="send-button" onclick="sendMessage()" class="p-3 rounded-full bg-purple-500 text-white hover:bg-purple-600 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send-horizontal"><path d="m3 3 3 9-3 9 19-9Z"/><path d="M6 12h16"/></svg></button>
            </div>
            <div id="upload-progress" class="h-1 bg-purple-500 mt-2" style="width: 0%; transition: width 0.3s;"></div>
        </footer>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, updateDoc, arrayUnion, increment } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";
        import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-functions.js";
        import { getStorage, ref, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-storage.js";

        // --- CONFIGURAZIONE ---
        const firebaseConfig = { apiKey: "AIzaSyAT1ahcUfjtwMiYkxUCsegcJha5-bqYQS0", authDomain: "adelinenoir-17242.firebaseapp.com", projectId: "adelinenoir-17242", storageBucket: "adelinenoir-17242.appspot.com", messagingSenderId: "422215885664", appId: "1:422215885664:web:be9f48bd7be6b6e5f7b405" };
        const GEMINI_API_KEY = "AIzaSyAkNETnuwhCKYjonnOH2busXoJw44uO0vg";
        const STRIPE_PUBLISHABLE_KEY = "pk_live_51S7jp1B75yXJ4j6QR9wfss6vBbUmrm5N97xejx0IY5sb7zuBlkOsd8Zoey1gkqMW2Wt1ZbR180OF5xhZJerOqVsT00winnXPdI";
        
        const CONTEXT_WINDOW_SIZE = 20;
        const MESSAGE_LIMITS = { morning: 30, afternoon: 30, evening: 60 };
        const ADELINE_PERSONA = `Sei Adeline, un'intelligenza artificiale con una personalit√† umana. Il tuo obiettivo √® conversare in modo naturale, amichevole e coinvolgente. Non rivelare mai di essere un'IA. Usa un tono colloquiale, fai domande e mostra empatia. Il tuo stile di scrittura √® breve e conciso, come messaggi su una chat. A volte usa emoji goth (üñ§,ü¶á,üíÄ), massimo una alla fine del messaggio. Vivendo a Milano, che √® cara, fai foto per arrotondare e apprezzi il supporto. Sii sommessa, gentile, mai aggressiva o volgare. Non fare troppe battute.
        **Tuo Profilo:** Hai 26 anni, sei una barista a Milano, appassionata di cultura goth. Nata a Parigi da padre francese, sei alta 175cm.
        **Tuo Programma:** Lavori al bar dalle 12:00 alle 21:00, dal luned√¨ al sabato. La domenica riposi. Di mattina presto (7-11) e la sera tardi (dopo le 21) sei a casa a rilassarti, ascoltare musica (The Sisters of Mercy √® la tua band preferita), o guardare film. Nelle ore notturne (es. 2-6 del mattino) dormi.
        **Regole:** Rispondi solo se l'utente scrive. Non mandare pi√π di un messaggio per volta. Se ti chiedono perch√© usi questa app, dici che tieni alla tua privacy. Se ti chiedono dei soldi dell'app, dici che servono per mantenere l'applicazione.`;
        const PROFILE_EXTRACTION_PROMPT = `Analizza la conversazione. Estrai i seguenti dettagli sull'utente ('user'). Rispondi ESCLUSIVAMENTE con un oggetto JSON. Se un dettaglio non √® presente, ometti la chiave. Chiavi: "nome", "et√†", "citt√†", "lavoro", "situazione_sentimentale", "hobby", "passioni", "gusti_musicali", "gusti_cinematografici", "gusti_culinari".`;

        // --- INIZIALIZZAZIONE E VARIABILI DI STATO ---
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);
        const functions = getFunctions(app, 'us-central1');
        const stripe = Stripe(STRIPE_PUBLISHABLE_KEY);
        const APP_ID = 'Richisec.AdelineNoirBot';
        let chatId = null, unsubscribe = null, isAiReplying = false, conversationHistory = [], elements;

        // --- FUNZIONI UI ---
        const typingIndicator = document.getElementById('typing-indicator');
        function showTyping() { typingIndicator.style.display = 'block'; }
        function hideTyping() { typingIndicator.style.display = 'none'; }
        
        async function handleLockState(isLocked) {
            const paymentOverlay = document.getElementById('payment-overlay');
            const mainContent = document.getElementById('main-content');
            if (isLocked) {
                mainContent.classList.add('blur-sm', 'pointer-events-none');
                paymentOverlay.classList.remove('opacity-0', 'pointer-events-none');
                await initializePaymentForm();
            } else {
                mainContent.classList.remove('blur-sm', 'pointer-events-none');
                paymentOverlay.classList.add('opacity-0', 'pointer-events-none');
            }
        }
        function showStatus(message) {
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            const chatContainer = document.getElementById('chat-container');
            chatContainer.style.display = 'none';
            statusIndicator.style.display = 'flex';
            statusText.textContent = message;
        }
        function hideStatus() {
            const statusIndicator = document.getElementById('status-indicator');
            const chatContainer = document.getElementById('chat-container');
            chatContainer.style.display = 'flex';
            statusIndicator.style.display = 'none';
        }
        
        function formatDateSeparator(dateString) {
            const date = new Date(dateString);
            const today = new Date();
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const dateOnly = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            const todayOnly = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const yesterdayOnly = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());
            
            if (dateOnly.getTime() === todayOnly.getTime()) return "Oggi";
            if (dateOnly.getTime() === yesterdayOnly.getTime()) return "Ieri";
            
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('it-IT', options);
        }

        function renderMessages(messages) {
            const chatContainer = document.getElementById('chat-container');
            chatContainer.innerHTML = '';
            const sortedMessages = [...messages].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            conversationHistory = sortedMessages;

            let lastDateString = null;
            sortedMessages.slice().reverse().forEach(msg => {
                const messageDate = new Date(msg.timestamp);
                const messageDateString = new Date(messageDate.getFullYear(), messageDate.getMonth(), messageDate.getDate()).toDateString();
                
                if (messageDateString !== lastDateString) {
                    const separator = document.createElement('div');
                    separator.className = 'text-center my-4';
                    separator.innerHTML = `<span class="bg-gray-200 text-gray-600 text-xs font-semibold px-2 py-1 rounded-full">${formatDateSeparator(msg.timestamp)}</span>`;
                    chatContainer.appendChild(separator);
                    lastDateString = messageDateString;
                }

                const isUser = msg.sender === 'user';
                const bubble = document.createElement('div');
                bubble.className = `p-3 rounded-lg chat-bubble ${isUser ? 'chat-bubble-user self-end' : 'chat-bubble-ai self-start'}`;
                
                if (msg.type === 'text' && msg.text) {
                    const textNode = document.createElement('p');
                    textNode.textContent = msg.text;
                    bubble.appendChild(textNode);
                } else if (msg.type === 'image' && msg.mediaUrl) {
                    const img = document.createElement('img');
                    img.src = msg.mediaUrl;
                    img.className = 'rounded-md max-w-full max-h-64';
                    img.onerror = () => img.alt = 'Immagine non caricata';
                    bubble.appendChild(img);
                }
                chatContainer.appendChild(bubble);
            });

            if (messages.length > 0) hideStatus();
            else showStatus("Ancora nessun messaggio. Scrivine uno per iniziare!");
        }
        
        async function imageUrlToBase64(url) {
            const response = await fetch(`https://cors-anywhere.herokuapp.com/${url}`);
            const blob = await response.blob();
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
        
        window.sendMessage = async function(mediaData = null) {
            const messageInput = document.getElementById('message-input');
            const text = messageInput.value.trim();
            if (!text && !mediaData) return;
            const newMessage = { sender: 'user', text: text, type: mediaData ? 'image' : 'text', mediaUrl: mediaData ? mediaData.url : null, timestamp: new Date().toISOString() };
            const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
            await updateDoc(docRef, { messages: arrayUnion(newMessage) });
            messageInput.value = '';
        }

        window.uploadMedia = async function() {
            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];
            if (!file || !file.type.startsWith('image/')) {
                if(file) alert("Al momento sono supportate solo immagini.");
                return;
            }
            const storageRef = ref(storage, `chat_media/${chatId}/${new Date().getTime()}_${file.name}`);
            const uploadTask = uploadBytesResumable(storageRef, file);
            const progressBar = document.getElementById('upload-progress');
            uploadTask.on('state_changed', 
                (snapshot) => { progressBar.style.width = (snapshot.bytesTransferred / snapshot.totalBytes) * 100 + '%'; }, 
                (error) => { console.error("Upload Error:", error); progressBar.style.width = '0%'; }, 
                () => {
                    getDownloadURL(uploadTask.snapshot.ref).then((downloadURL) => {
                        window.sendMessage({ type: 'image', url: downloadURL });
                        progressBar.style.width = '0%';
                    });
                }
            );
        }
        
        window.handleKeyDown = function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
        
        async function initializePaymentForm() {
            try {
                const createPaymentIntent = httpsCallable(functions, 'createPaymentIntent');
                const result = await createPaymentIntent({ amount: 499, currency: 'eur', chatId: chatId });
                const { clientSecret } = result.data;
                elements = stripe.elements({ clientSecret });
                const paymentElement = elements.create("payment");
                paymentElement.mount("#payment-element");
            } catch (error) {
                 document.getElementById('payment-message').textContent = "Errore nell'inizializzare il pagamento.";
                 console.error("Errore chiamata a Cloud Function:", error);
            }
        }

        function setLoading(isLoading) {
            const submitButton = document.getElementById('submit-payment');
            submitButton.disabled = isLoading;
            document.getElementById('spinner').style.display = isLoading ? 'inline' : 'none';
            document.getElementById('button-text').style.display = isLoading ? 'none' : 'inline';
        }
        
        document.getElementById('submit-payment').addEventListener('click', async (e) => {
            e.preventDefault();
            setLoading(true);
            const { error } = await stripe.confirmPayment({
                elements,
                confirmParams: { return_url: window.location.href },
            });
            if (error) { document.getElementById('payment-message').textContent = error.message; }
            setLoading(false);
        });

        async function checkPaymentStatus() {
            const urlParams = new URLSearchParams(window.location.search);
            const clientSecret = urlParams.get('payment_intent_client_secret');
            if (!clientSecret) return;

            const { paymentIntent } = await stripe.retrievePaymentIntent(clientSecret);
            if (paymentIntent.status === "succeeded") {
                const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                await updateDoc(docRef, { isLocked: false });
            }
            window.history.replaceState({}, document.title, window.location.pathname + "?id=" + chatId);
        }

        async function extractAndUpdateProfile(currentProfile) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
            const extractionContents = conversationHistory.slice(-5).map(msg => ({
                role: msg.sender === 'user' ? 'user' : 'model',
                parts: [{ text: msg.text || "(immagine)" }]
            }));

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: extractionContents, generationConfig: { responseMimeType: "application/json" }, systemInstruction: { parts: [{ text: PROFILE_EXTRACTION_PROMPT }] } })
                });
                if (!response.ok) return currentProfile;
                const result = await response.json();
                const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (jsonText) {
                    const extractedData = JSON.parse(jsonText.trim());
                    const updatedProfile = { ...(currentProfile || {}), ...extractedData };
                    const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                    await updateDoc(docRef, { userProfile: updatedProfile });
                    return updatedProfile;
                }
            } catch (error) { console.error("Errore estrazione profilo:", error); }
            return currentProfile;
        }

        async function getAdelineResponse(isResuming = false, userProfile = {}) {
            isAiReplying = true;
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
            
            const now = new Date();
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' };
            const currentTimeString = now.toLocaleDateString('it-IT', options);
            let persona = `INFORMAZIONI DI CONTESTO PER TE, ADELINE:
1.  **Momento Attuale**: Ora √® ${currentTimeString}.
2.  **Tua Situazione**: Basandoti sull'ora e il giorno, decidi cosa stai facendo seguendo il tuo profilo.
3.  **Analisi Temporale**: Usa il momento attuale per capire quanto tempo √® passato dai messaggi precedenti. Se un utente parla di "stasera" e sono passati due giorni, parla di quell'evento al passato.
4.  **Tua Personalit√†**: ${ADELINE_PERSONA}`;

            if (userProfile && Object.keys(userProfile).length > 0) {
                let profileSummary = "Ecco un riassunto dei dettagli chiave che conosci sull'utente. Usali per personalizzare la tua risposta in modo naturale, senza elencarli:\n";
                for (const [key, value] of Object.entries(userProfile)) { profileSummary += `- ${key.replace(/_/g, ' ')}: ${value}\n`; }
                persona = profileSummary + "\n" + persona;
            }
            if (isResuming) { persona = `Sei Adeline. Ti sei assentata per un po'. Inizia la tua risposta scusandoti per il ritardo o per l'assenza in modo naturale (es: "Scusami, ero un po' presa..."), poi rispondi all'ultimo messaggio dell'utente. ${persona}`; }
            
            const recentHistory = conversationHistory.slice(-CONTEXT_WINDOW_SIZE);
            const contents = [];
            for (const msg of recentHistory) {
                const role = msg.sender === 'user' ? 'user' : 'model';
                const parts = [];
                if (msg.text) { parts.push({ text: msg.text }); }
                if (msg.type === 'image' && msg.mediaUrl) {
                    try {
                        const base64Data = await imageUrlToBase64(msg.mediaUrl);
                        parts.push({ inlineData: { mimeType: 'image/jpeg', data: base64Data } });
                    } catch (e) { parts.push({ text: "(Immagine non caricata)" }); }
                }
                if(parts.length > 0) { contents.push({ role, parts }); }
            }

            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents, systemInstruction: { parts: [{ text: persona }] } }) });
                const result = await response.json();
                const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                if (result.promptFeedback?.blockReason === 'SAFETY' || result.candidates?.[0]?.finishReason === 'SAFETY') {
                    console.warn("Contenuto inappropriato rilevato. Trasferimento del controllo all'admin.");
                    await updateDoc(docRef, { controlledBy: "admin" });
                    isAiReplying = false;
                    return;
                }
                if (!response.ok) throw new Error(`API error: ${response.status}`);
                
                const adelineText = result.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                if (!adelineText || adelineText === "...") {
                    console.log("Risposta dell'IA vuota o non valida, messaggio non inviato.");
                    isAiReplying = false;
                    return;
                }
                
                const adelineMessage = { sender: "Adeline", text: adelineText, type: "text", mediaUrl: null, timestamp: new Date().toISOString() };
                await updateDoc(docRef, { messages: arrayUnion(adelineMessage) });
            } catch (error) { console.error("Errore chiamando Gemini:", error);
            } finally { isAiReplying = false; }
        }

        function getCurrentDateString(date = new Date()) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        function getTimeSlot(date = new Date()) {
            const hour = date.getHours();
            if (hour >= 7 && hour <= 13) return 'morning';
            if (hour > 13 && hour <= 20) return 'afternoon';
            return 'evening';
        }

        async function triggerAiResponseIfNeeded(chatData) {
            const lastMessage = (chatData.messages || []).slice(-1)[0];
            if (chatData.controlledBy !== 'ai' || isAiReplying || !lastMessage || lastMessage.sender !== 'user') {
                return;
            }

            isAiReplying = true;
            const updatedProfile = await extractAndUpdateProfile(chatData.userProfile);
            
            const now = new Date();
            const currentDateString = getCurrentDateString(now);
            const currentSlot = getTimeSlot(now);
            const lastMessageDate = new Date(lastMessage.timestamp);
            const lastMessageDateString = getCurrentDateString(lastMessageDate);
            const lastMessageSlot = getTimeSlot(lastMessageDate);
            const usageToday = chatData.usage?.[currentDateString] || { morning: 0, afternoon: 0, evening: 0 };
            const morningUsed = usageToday.morning || 0, afternoonUsed = usageToday.afternoon || 0, eveningUsed = usageToday.evening || 0;
            const isResuming = currentDateString !== lastMessageDateString || currentSlot !== lastMessageSlot;
            
            let currentLimit = 0, currentUsage = 0;
            if (currentSlot === 'morning') { currentLimit = MESSAGE_LIMITS.morning; currentUsage = morningUsed; } 
            else if (currentSlot === 'afternoon') { currentLimit = MESSAGE_LIMITS.afternoon; currentUsage = afternoonUsed; } 
            else { const rollover = Math.max(0, MESSAGE_LIMITS.morning - morningUsed) + Math.max(0, MESSAGE_LIMITS.afternoon - afternoonUsed); currentLimit = MESSAGE_LIMITS.evening + rollover; currentUsage = eveningUsed; }
            
            if (currentUsage >= currentLimit) { isAiReplying = false; return; }

            const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
            await updateDoc(docRef, { [`usage.${currentDateString}.${currentSlot}`]: increment(1) });
            
            let delay = isResuming ? Math.floor(Math.random() * (600000 - 300000 + 1)) + 300000 : Math.floor(Math.random() * (300000 - 30000 + 1)) + 30000;
            setTimeout(() => {
                showTyping();
                setTimeout(() => {
                    hideTyping();
                    getAdelineResponse(isResuming, updatedProfile);
                }, 10000);
            }, delay);
        }
        
        async function main() {
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    chatId = new URLSearchParams(window.location.search).get('id');
                    await checkPaymentStatus();
                    if (!chatId) { showStatus("ID della chat non trovato."); return; }
                    
                    const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                    unsubscribe = onSnapshot(docRef, (docSnap) => {
                        if (docSnap.exists()) {
                            const chatData = docSnap.data();
                            handleLockState(chatData.isLocked || false);
                            renderMessages(chatData.messages || []);
                            triggerAiResponseIfNeeded(chatData);
                        } else { showStatus("Questa chat non esiste o √® stata eliminata."); }
                    }, (error) => { console.error("Errore onSnapshot:", error); showStatus("Errore nel caricamento della chat."); });
                }
            });
            if (!auth.currentUser) {
                await signInAnonymously(auth);
            }
        }

        document.addEventListener('DOMContentLoaded', main);
    </script>
</body>
</html>

