<!DOCTYPE html>
<html lang="it" class="h-full bg-gray-100">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adeline Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://js.stripe.com/v3/"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .chat-bubble { max-width: 75%; }
        .chat-bubble-user { background-color: #3b82f6; color: white; }
        .chat-bubble-ai { background-color: #e5e7eb; color: #1f2937; }
        #chat-container { display: flex; flex-direction: column-reverse; overflow-y: auto; flex-grow: 1; }
        #payment-overlay { transition: opacity 0.3s ease-in-out; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="h-full flex flex-col relative">

    <!-- Banner per richiesta permessi notifiche -->
    <div id="notification-banner" class="fixed bottom-0 left-0 right-0 bg-gray-800 text-white p-4 flex items-center justify-center space-x-4 z-50 hidden">
        <p>Vuoi ricevere una notifica quando Adeline ti scrive?</p>
        <button id="allow-notifications" class="bg-purple-500 hover:bg-purple-600 px-4 py-2 rounded-lg font-semibold">Abilita</button>
        <button id="deny-notifications" class="bg-gray-600 hover:bg-gray-700 px-4 py-2 rounded-lg">No, grazie</button>
    </div>

    <!-- Schermata di Pagamento -->
    <div id="payment-overlay" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50 opacity-0 pointer-events-none">
        <div class="bg-white rounded-lg shadow-xl p-8 max-w-sm w-full text-center">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Chat Interrotta</h2>
            <p class="text-gray-600 mb-6">Funzionalità Premium terminata, continua per riaprire la chat e continuare a parlare</p>
            <div id="payment-element" class="mb-6"></div>
            <button id="submit-payment" class="w-full bg-purple-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-purple-700 transition-colors disabled:bg-gray-400">
                <span id="button-text">Paga ora 4,99€</span>
                <span id="spinner" class="hidden">Elaborazione...</span>
            </button>
            <p id="payment-message" class="text-sm text-red-500 mt-4"></p>
        </div>
    </div>

    <!-- Contenuto principale della chat -->
    <div id="main-content" class="h-full flex flex-col">
        <header class="bg-white shadow-md p-4 flex items-center space-x-4 z-10">
            <div class="w-12 h-12 rounded-full bg-purple-500 flex items-center justify-center text-white text-xl font-bold">A</div>
            <div><h1 class="text-xl font-bold text-gray-800">Adeline</h1></div>
        </header>
        <main id="chat-container" class="p-4 space-y-4"></main>
        <div id="status-indicator" class="flex-grow flex items-center justify-center">
            <p id="status-text" class="text-gray-500 text-center p-4">Caricamento della chat...</p>
        </div>
        <div id="typing-indicator" class="p-4 hidden"><p class="text-gray-500 italic">Adeline sta scrivendo...</p></div>
        <footer class="bg-white p-4 border-t border-gray-200">
            <div class="flex items-center space-x-2">
                <input type="file" id="file-input" class="hidden" accept="image/*" onchange="uploadMedia()">
                <button onclick="document.getElementById('file-input').click()" class="p-3 rounded-full hover:bg-gray-200 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-600"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg></button>
                <input type="text" id="message-input" placeholder="Scrivi un messaggio..." class="flex-grow p-3 border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-purple-500" onkeydown="handleKeyDown(event)">
                <button id="send-button" onclick="sendMessage()" class="p-3 rounded-full bg-purple-500 text-white hover:bg-purple-600 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send-horizontal"><path d="m3 3 3 9-3 9 19-9Z"/><path d="M6 12h16"/></svg></button>
            </div>
            <div id="upload-progress" class="h-1 bg-purple-500 mt-2" style="width: 0%; transition: width 0.3s;"></div>
        </footer>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, updateDoc, arrayUnion, increment, getDoc } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";
        import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-functions.js";
        import { getStorage, ref, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-storage.js";

        // --- CONFIGURAZIONE ---
        const firebaseConfig = { apiKey: "AIzaSyAT1ahcUfjtwMiYkxUCsegcJha5-bqYQS0", authDomain: "adelinenoir-17242.firebaseapp.com", projectId: "adelinenoir-17242", storageBucket: "adelinenoir-17242.appspot.com", messagingSenderId: "422215885664", appId: "1:422215885664:web:be9f48bd7be6b6e5f7b405" };
        const GEMINI_API_KEY = "AIzaSyAkNETnuwhCKYjonnOH2busXoJw44uO0vg";
        const STRIPE_PUBLISHABLE_KEY = "pk_live_51S7jp1B75yXJ4j6QR9wfss6vBbUmrm5N97xejx0IY5sb7zuBlkOsd8Zoey1gkqMW2Wt1ZbR180OF5xhZJerOqVsT00winnXPdI";
        
        const CONTEXT_WINDOW_SIZE = 20;
        const MESSAGE_LIMITS = { morning: 30, afternoon: 30, evening: 60 };
        const PROFILE_EXTRACTION_PROMPT = `Analizza la conversazione. Estrai i seguenti dettagli sull'utente ('user'). Rispondi ESCLUSIVAMENTE con un oggetto JSON. Se un dettaglio non è presente, ometti la chiave. Chiavi: "nome", "età", "città", "lavoro", "situazione_sentimentale", "hobby", "passioni", "gusti_musicali", "gusti_cinematografici", "gusti_culinari".`;

        // --- INIZIALIZZAZIONE E VARIABILI DI STATO ---
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);
        const functions = getFunctions(app, 'us-central1');
        const stripe = Stripe(STRIPE_PUBLISHABLE_KEY);
        const APP_ID = 'Richisec.AdelineNoirBot';
        let chatId = null, unsubscribe = null, isAiReplying = false, conversationHistory = [], elements;
        let adelinePersona = ""; 
        let userGender = "";
        let lastKnownMessageId = null;
        let isCheckingSafety = false;

        // --- FUNZIONI NOTIFICHE ---
        function showNotification(title, body) {
            if (Notification.permission === 'granted') {
                const iconUrl = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="%238B5CF6"/><text x="50" y="50" font-family="Arial" font-size="50" fill="white" text-anchor="middle" dy=".3em">A</text></svg>';
                new Notification(title, { body, icon: iconUrl });
            }
        }

        function initializeNotifications() {
            if (!('Notification' in window)) { return; }
            const banner = document.getElementById('notification-banner');
            const allowButton = document.getElementById('allow-notifications');
            const denyButton = document.getElementById('deny-notifications');
            if (Notification.permission === 'default') { banner.classList.remove('hidden'); }
            allowButton.addEventListener('click', () => {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') { showNotification('Grazie!', 'Ora riceverai le notifiche da Adeline.'); }
                    banner.classList.add('hidden');
                });
            });
            denyButton.addEventListener('click', () => { banner.classList.add('hidden'); });
        }

        // --- FUNZIONI UI ---
        const typingIndicator = document.getElementById('typing-indicator');
        function showTyping() { typingIndicator.style.display = 'block'; }
        function hideTyping() { typingIndicator.style.display = 'none'; }
        
        async function handleLockState(isLocked) {
            const paymentOverlay = document.getElementById('payment-overlay');
            const mainContent = document.getElementById('main-content');
            if (isLocked) {
                mainContent.classList.add('blur-sm', 'pointer-events-none');
                paymentOverlay.classList.remove('opacity-0', 'pointer-events-none');
                await initializePaymentForm();
            } else {
                mainContent.classList.remove('blur-sm', 'pointer-events-none');
                paymentOverlay.classList.add('opacity-0', 'pointer-events-none');
            }
        }
        function showStatus(message) {
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            const chatContainer = document.getElementById('chat-container');
            chatContainer.style.display = 'none';
            statusIndicator.style.display = 'flex';
            statusText.textContent = message;
        }
        function hideStatus() {
            const statusIndicator = document.getElementById('status-indicator');
            const chatContainer = document.getElementById('chat-container');
            chatContainer.style.display = 'flex';
            statusIndicator.style.display = 'none';
        }
        
        function formatDateSeparator(dateString) {
            const date = new Date(dateString);
            const today = new Date();
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const dateOnly = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            const todayOnly = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const yesterdayOnly = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());
            
            if (dateOnly.getTime() === todayOnly.getTime()) return "Oggi";
            if (dateOnly.getTime() === yesterdayOnly.getTime()) return "Ieri";
            
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('it-IT', options);
        }

        function renderMessages(messages) {
            const chatContainer = document.getElementById('chat-container');
            chatContainer.innerHTML = '';
            const sortedMessages = [...messages].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            conversationHistory = sortedMessages;

            let lastDateString = null;
            sortedMessages.slice().reverse().forEach(msg => {
                const messageDate = new Date(msg.timestamp);
                const messageDateString = new Date(messageDate.getFullYear(), messageDate.getMonth(), messageDate.getDate()).toDateString();
                
                if (messageDateString !== lastDateString) {
                    const separator = document.createElement('div');
                    separator.className = 'text-center my-4';
                    separator.innerHTML = `<span class="bg-gray-200 text-gray-600 text-xs font-semibold px-2 py-1 rounded-full">${formatDateSeparator(msg.timestamp)}</span>`;
                    chatContainer.appendChild(separator);
                    lastDateString = messageDateString;
                }

                const isUser = msg.sender === 'user';
                const bubble = document.createElement('div');
                bubble.className = `p-3 rounded-lg chat-bubble ${isUser ? 'chat-bubble-user self-end' : 'chat-bubble-ai self-start'}`;
                
                if (msg.type === 'text' && msg.text) {
                    const textNode = document.createElement('p');
                    textNode.textContent = msg.text;
                    bubble.appendChild(textNode);
                } else if (msg.type === 'image' && msg.mediaUrl) {
                    const img = document.createElement('img');
                    img.src = msg.mediaUrl;
                    img.className = 'rounded-md max-w-full max-h-64';
                    img.onerror = () => img.alt = 'Immagine non caricata';
                    bubble.appendChild(img);
                }
                chatContainer.appendChild(bubble);
            });

            if (messages.length > 0) hideStatus();
            else showStatus("Ancora nessun messaggio. Scrivine uno per iniziare!");
        }
        
        async function imageUrlToBase64(url) {
            const response = await fetch(`https://cors-anywhere.herokuapp.com/${url}`);
            const blob = await response.blob();
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
        
        window.sendMessage = async function(mediaData = null) {
            const messageInput = document.getElementById('message-input');
            const text = messageInput.value.trim();
            if (!text && !mediaData) return;
            const newMessage = { messageId: crypto.randomUUID(), sender: 'user', text: text, type: mediaData ? 'image' : 'text', mediaUrl: mediaData ? mediaData.url : null, timestamp: new Date().toISOString() };
            const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
            await updateDoc(docRef, { messages: arrayUnion(newMessage) });
            messageInput.value = '';
        }

        window.uploadMedia = async function() {
            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];
            if (!file || !file.type.startsWith('image/')) {
                if(file) alert("Al momento sono supportate solo immagini.");
                return;
            }
            const storageRef = ref(storage, `chat_media/${chatId}/${new Date().getTime()}_${file.name}`);
            const uploadTask = uploadBytesResumable(storageRef, file);
            const progressBar = document.getElementById('upload-progress');
            uploadTask.on('state_changed', 
                (snapshot) => { progressBar.style.width = (snapshot.bytesTransferred / snapshot.totalBytes) * 100 + '%'; }, 
                (error) => { console.error("Upload Error:", error); progressBar.style.width = '0%'; }, 
                () => {
                    getDownloadURL(uploadTask.snapshot.ref).then((downloadURL) => {
                        window.sendMessage({ type: 'image', url: downloadURL });
                        progressBar.style.width = '0%';
                    });
                }
            );
        }
        
        window.handleKeyDown = function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
        
        async function initializePaymentForm() {
            try {
                const createPaymentIntent = httpsCallable(functions, 'createPaymentIntent');
                const result = await createPaymentIntent({ amount: 499, currency: 'eur', chatId: chatId });
                const { clientSecret } = result.data;
                elements = stripe.elements({ clientSecret });
                const paymentElement = elements.create("payment");
                paymentElement.mount("#payment-element");
            } catch (error) {
                 document.getElementById('payment-message').textContent = "Errore nell'inizializzare il pagamento.";
                 console.error("Errore chiamata a Cloud Function:", error);
            }
        }

        function setLoading(isLoading) {
            const submitButton = document.getElementById('submit-payment');
            submitButton.disabled = isLoading;
            document.getElementById('spinner').style.display = isLoading ? 'inline' : 'none';
            document.getElementById('button-text').style.display = isLoading ? 'none' : 'inline';
        }
        
        document.getElementById('submit-payment').addEventListener('click', async (e) => {
            e.preventDefault();
            setLoading(true);
            const { error } = await stripe.confirmPayment({
                elements,
                confirmParams: { return_url: window.location.href },
            });
            if (error) { document.getElementById('payment-message').textContent = error.message; }
            setLoading(false);
        });

        async function checkPaymentStatus() {
            const urlParams = new URLSearchParams(window.location.search);
            const clientSecret = urlParams.get('payment_intent_client_secret');
            if (!clientSecret) return;

            const { paymentIntent } = await stripe.retrievePaymentIntent(clientSecret);
            if (paymentIntent.status === "succeeded") {
                const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                await updateDoc(docRef, { isLocked: false });
            }
            window.history.replaceState({}, document.title, window.location.pathname + "?id=" + chatId);
        }
        
        async function getPersona(nationality) {
            try {
                const personaDocRef = doc(db, "personas", nationality);
                const personaDoc = await getDoc(personaDocRef);
                if (personaDoc.exists()) {
                    return personaDoc.data().personaText;
                } else {
                    console.warn(`Personalità per "${nationality}" non trovata. Uso fallback.`);
                    const fallbackDoc = await getDoc(doc(db, "personas", "it"));
                    return fallbackDoc.exists() ? fallbackDoc.data().personaText : "Sono Adeline, piacere di conoscerti.";
                }
            } catch (error) {
                console.error("Errore nel caricare la personalità:", error);
                return "Sono Adeline, piacere di conoscerti.";
            }
        }

        async function extractAndUpdateProfile(currentProfile) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
            const extractionContents = conversationHistory.slice(-5).map(msg => ({
                role: msg.sender === 'user' ? 'user' : 'model',
                parts: [{ text: msg.text || "(immagine)" }]
            }));

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: extractionContents, generationConfig: { responseMimeType: "application/json" }, systemInstruction: { parts: [{ text: PROFILE_EXTRACTION_PROMPT }] } })
                });
                if (!response.ok) return currentProfile;
                const result = await response.json();
                const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (jsonText) {
                    const extractedData = JSON.parse(jsonText.trim());
                    const updatedProfile = { ...(currentProfile || {}), ...extractedData };
                    const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                    await updateDoc(docRef, { userProfile: updatedProfile });
                    return updatedProfile;
                }
            } catch (error) { console.error("Errore estrazione profilo:", error); }
            return currentProfile;
        }

        async function buildFullPersona(userProfile = {}) {
            if (!adelinePersona) { return null; }
            
            const now = new Date();
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' };
            const currentTimeString = now.toLocaleDateString('it-IT', options);
            
            let genderInstruction = "";
            if (userGender === 'male') {
                genderInstruction = "\n5. **Regola Grammaticale Cruciale**: Riferisciti sempre all'utente usando il genere maschile (es. 'sei stanco', 'sei un bravo ragazzo', 'ciao bello').";
            } else if (userGender === 'female') {
                genderInstruction = "\n5. **Regola Grammaticale Cruciale**: Riferisciti sempre all'utente usando il genere femminile (es. 'sei stanca', 'sei una brava ragazza', 'ciao bella').";
            }
            
            let persona = `INFORMAZIONI DI CONTESTO PER TE, ADELINE:
1.  **Momento Attuale**: Ora è ${currentTimeString}.
2.  **Tua Situazione**: Basandoti sull'ora e il giorno, decidi cosa stai facendo seguendo il tuo profilo.
3.  **Analisi Temporale**: Usa il momento attuale per capire quanto tempo è passato dai messaggi precedenti.
4.  **Tua Personalità**: ${adelinePersona}${genderInstruction}`;

            if (userProfile && Object.keys(userProfile).length > 0) {
                let profileSummary = "Ecco un riassunto dei dettagli chiave sull'utente:\n";
                for (const [key, value] of Object.entries(userProfile)) { profileSummary += `- ${key.replace(/_/g, ' ')}: ${value}\n`; }
                persona = profileSummary + "\n" + persona;
            }
            return persona;
        }

        async function getAdelineResponse(isResuming = false, userProfile = {}) {
            let persona = await buildFullPersona(userProfile);
            if (!persona) {
                console.error("La personalità di Adeline non è stata caricata. Impossibile rispondere.");
                return;
            }
            isAiReplying = true;
            if (isResuming) { persona = `Sei Adeline. Ti sei assentata per un po'. Inizia la tua risposta scusandoti per il ritardo o per l'assenza in modo naturale (es: "Scusami, ero un po' presa..."), poi rispondi all'ultimo messaggio dell'utente. ${persona}`; }
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
            const recentHistory = conversationHistory.slice(-CONTEXT_WINDOW_SIZE);
            const contents = recentHistory.map(msg => ({
                role: msg.sender === 'user' ? 'user' : 'model',
                parts: [{ text: msg.text || "(immagine)" }]
            }));

            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents, systemInstruction: { parts: [{ text: persona }] } }) });
                const result = await response.json();
                const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                
                // Il controllo di sicurezza primario avviene prima, nella funzione 'checkMessageForHandoff'.
                // Manteniamo questo come fallback nel caso in cui la risposta venga comunque bloccata.
                const safetyBlock = result.promptFeedback?.blockReason === 'SAFETY' || result.candidates?.[0]?.finishReason === 'SAFETY';
                if (safetyBlock) {
                    console.warn("Blocco di sicurezza API rilevato (fallback). Trasferimento al bot NSFW.");
                    await updateDoc(docRef, { controlledBy: "NSFW" });
                    isAiReplying = false;
                    return;
                }

                if (!response.ok) throw new Error(`API error: ${response.status}`);
                
                const adelineText = result.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                const uselessResponses = ["...", "Non so cosa dire."];
                if (!adelineText || uselessResponses.includes(adelineText)) {
                    console.log("Risposta dell'IA vuota o non valida, messaggio non inviato.");
                    isAiReplying = false; 
                    return;
                }
                
                const adelineMessage = { messageId: crypto.randomUUID(), sender: "Adeline", text: adelineText, type: "text", mediaUrl: null, timestamp: new Date().toISOString() };
                await updateDoc(docRef, { messages: arrayUnion(adelineMessage) });
            } catch (error) { console.error("Errore chiamando Gemini:", error);
            } finally { isAiReplying = false; }
        }
        
        // --- NUOVA FUNZIONE DI CONTROLLO PREVENTIVO ---
        async function checkMessageForHandoff(message) {
            if (!message || message.sender !== 'user' || !message.text) {
                return false;
            }

            const handoffSystemPrompt = `Analyze the user's message. Is it sexually explicit, pornographic, or requesting an erotic roleplay? Answer ONLY with "yes" or "no".`;
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
            const contents = [{ role: 'user', parts: [{ text: message.text }] }];

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents, systemInstruction: { parts: [{ text: handoffSystemPrompt }] } })
                });

                if (!response.ok) {
                    console.error("Handoff check API error:", response.status);
                    return false;
                }

                const result = await response.json();
                const classification = result.candidates?.[0]?.content?.parts?.[0]?.text?.trim().toLowerCase();

                if (classification === 'yes') {
                    console.warn("Messaggio esplicito rilevato dal pre-controllo. Trasferimento al bot NSFW.");
                    const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                    await updateDoc(docRef, { controlledBy: "NSFW" });
                    return true; // Handoff avvenuto
                }
                return false; // Nessun handoff necessario
            } catch (error) {
                console.error("Errore durante il controllo per l'handoff:", error);
                return false;
            }
        }

        async function checkAndResumeSFWControl(chatData) {
            if (isCheckingSafety) return;
            isCheckingSafety = true;

            console.log("Controllo di sicurezza in corso per riprendere il controllo...");
            
            const userProfile = chatData.userProfile || {};
            let persona = await buildFullPersona(userProfile);
            if (!persona) {
                console.error("Personalità non caricata, impossibile eseguire il controllo di sicurezza.");
                isCheckingSafety = false;
                return;
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
            const recentHistory = (chatData.messages || []).slice(-CONTEXT_WINDOW_SIZE);
            const contents = recentHistory.map(msg => ({
                role: msg.sender === 'user' ? 'user' : 'model',
                parts: [{ text: msg.text || "(immagine)" }]
            }));

            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents, systemInstruction: { parts: [{ text: persona }] } }) });
                const result = await response.json();
                const isSafe = !result.promptFeedback?.blockReason && result.candidates?.[0]?.finishReason !== 'SAFETY';

                if (isSafe && result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    console.log("Conversazione tornata a un livello sicuro. Gemini riprende il controllo.");
                    const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                    await updateDoc(docRef, { controlledBy: 'ai' });
                } else {
                    console.log("Il contenuto è ancora inappropriato per Gemini. Il bot NSFW continua.");
                }
            } catch (error) {
                console.error("Errore durante il controllo di sicurezza:", error);
            } finally {
                isCheckingSafety = false;
            }
        }

        function getCurrentDateString(date = new Date()) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        function getTimeSlot(date = new Date()) {
            const hour = date.getHours();
            if (hour >= 7 && hour <= 13) return 'morning';
            if (hour > 13 && hour <= 20) return 'afternoon';
            return 'evening';
        }

        async function triggerAiResponseIfNeeded(chatData) {
            const lastMessage = (chatData.messages || []).slice(-1)[0];
            if (isAiReplying || !lastMessage || lastMessage.sender !== 'user') {
                return;
            }

            isAiReplying = true;
            const updatedProfile = await extractAndUpdateProfile(chatData.userProfile);
            
            const now = new Date();
            const currentDateString = getCurrentDateString(now);
            const currentSlot = getTimeSlot(now);
            const lastMessageDate = new Date(lastMessage.timestamp);
            const lastMessageDateString = getCurrentDateString(lastMessageDate);
            const lastMessageSlot = getTimeSlot(lastMessageDate);
            const usageToday = chatData.usage?.[currentDateString] || { morning: 0, afternoon: 0, evening: 0 };
            const morningUsed = usageToday.morning || 0, afternoonUsed = usageToday.afternoon || 0, eveningUsed = usageToday.evening || 0;
            const isResuming = currentDateString !== lastMessageDateString || currentSlot !== lastMessageSlot;
            
            let currentLimit = 0, currentUsage = 0;
            if (currentSlot === 'morning') { currentLimit = MESSAGE_LIMITS.morning; currentUsage = morningUsed; } 
            else if (currentSlot === 'afternoon') { currentLimit = MESSAGE_LIMITS.afternoon; currentUsage = afternoonUsed; } 
            else { const rollover = Math.max(0, MESSAGE_LIMITS.morning - morningUsed) + Math.max(0, MESSAGE_LIMITS.afternoon - afternoonUsed); currentLimit = MESSAGE_LIMITS.evening + rollover; currentUsage = eveningUsed; }
            
            if (currentUsage >= currentLimit) { isAiReplying = false; return; }

            const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
            await updateDoc(docRef, { [`usage.${currentDateString}.${currentSlot}`]: increment(1) });
            
            let delay = isResuming ? Math.floor(Math.random() * (600000 - 300000 + 1)) + 300000 : Math.floor(Math.random() * (300000 - 30000 + 1)) + 30000;
            setTimeout(() => {
                showTyping();
                setTimeout(() => {
                    hideTyping();
                    getAdelineResponse(isResuming, updatedProfile);
                }, 10000);
            }, delay);
        }
        
        async function main() {
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    chatId = new URLSearchParams(window.location.search).get('id');
                    await checkPaymentStatus();
                    if (!chatId) { showStatus("ID della chat non trovato."); return; }
                    
                    initializeNotifications();
                    
                    const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                    unsubscribe = onSnapshot(docRef, async (docSnap) => {
                        if (docSnap.exists()) {
                            const chatData = docSnap.data();
                            
                            if (!adelinePersona) {
                                adelinePersona = await getPersona(chatData.nationality || "it");
                                userGender = chatData.gender || ""; 
                            }

                            handleLockState(chatData.isLocked || false);
                            renderMessages(chatData.messages || []);
                            
                            const latestMessage = (chatData.messages && chatData.messages.length > 0) ? chatData.messages.slice(-1)[0] : null;
                            const isNewMessageFromUser = latestMessage && latestMessage.sender === 'user' && latestMessage.messageId !== lastKnownMessageId;

                            if (latestMessage && latestMessage.messageId !== lastKnownMessageId && latestMessage.sender !== 'user') {
                                if (document.hidden) {
                                    showNotification('Nuovo messaggio da Adeline', latestMessage.text || 'Ha inviato un\'immagine.');
                                }
                            }

                            // --- NUOVA LOGICA DI CONTROLLO ---
                            if (isNewMessageFromUser) {
                                if (chatData.controlledBy === 'ai') {
                                    const didHandoff = await checkMessageForHandoff(latestMessage);
                                    if (!didHandoff) {
                                        triggerAiResponseIfNeeded(chatData);
                                    }
                                } else if (chatData.controlledBy === 'NSFW') {
                                    checkAndResumeSFWControl(chatData);
                                }
                            }
                            
                            lastKnownMessageId = latestMessage ? latestMessage.messageId : null;

                        } else { showStatus("Questa chat non esiste o è stata eliminata."); }
                    }, (error) => { console.error("Errore onSnapshot:", error); showStatus("Errore nel caricamento della chat."); });
                }
            });
            if (!auth.currentUser) {
                await signInAnonymously(auth);
            }
        }

        document.addEventListener('DOMContentLoaded', main);
    </script>
</body>
</html>

