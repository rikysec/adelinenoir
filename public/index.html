<!DOCTYPE html>
<html lang="it" class="h-full bg-gray-100">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adeline Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://js.stripe.com/v3/"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .chat-bubble { max-width: 75%; }
        .chat-bubble-user { background-color: #3b82f6; color: white; }
        .chat-bubble-ai { background-color: #e5e7eb; color: #1f2937; }
        #chat-container { display: flex; flex-direction: column-reverse; overflow-y: auto; flex-grow: 1; }
        #payment-overlay { transition: opacity 0.3s ease-in-out; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="h-full flex flex-col relative">

    <!-- Schermata di Pagamento -->
    <div id="payment-overlay" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50 opacity-0 pointer-events-none">
        <div class="bg-white rounded-lg shadow-xl p-8 max-w-sm w-full text-center">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Chat Interrotta</h2>
            <p class="text-gray-600 mb-6">Funzionalità Premium terminata, continua per riaprire la chat e continuare a parlare</p>
            <div id="payment-element" class="mb-6"></div>
            <button id="submit-payment" class="w-full bg-purple-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-purple-700 transition-colors disabled:bg-gray-400">
                <span id="button-text">Paga ora 4,99€</span>
                <span id="spinner" class="hidden">Elaborazione...</span>
            </button>
            <p id="payment-message" class="text-sm text-red-500 mt-4"></p>
        </div>
    </div>

    <!-- Contenuto principale della chat -->
    <div id="main-content" class="h-full flex flex-col">
        <header class="bg-white shadow-md p-4 flex items-center space-x-4 z-10">
            <div class="w-12 h-12 rounded-full bg-purple-500 flex items-center justify-center text-white text-xl font-bold">A</div>
            <div><h1 class="text-xl font-bold text-gray-800">Adeline</h1></div>
        </header>
        <main id="chat-container" class="p-4 space-y-4"></main>
        <div id="status-indicator" class="flex-grow flex items-center justify-center">
            <p id="status-text" class="text-gray-500 text-center p-4">Caricamento della chat...</p>
        </div>
        <div id="typing-indicator" class="p-4 hidden"><p class="text-gray-500 italic">Adeline sta scrivendo...</p></div>
        <footer class="bg-white p-4 border-t border-gray-200">
            <div class="flex items-center space-x-2">
                <input type="file" id="file-input" class="hidden" accept="image/*" onchange="uploadMedia()">
                <button onclick="document.getElementById('file-input').click()" class="p-3 rounded-full hover:bg-gray-200 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-600"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg></button>
                <input type="text" id="message-input" placeholder="Scrivi un messaggio..." class="flex-grow p-3 border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-purple-500" onkeydown="handleKeyDown(event)">
                <button id="send-button" onclick="sendMessage()" class="p-3 rounded-full bg-purple-500 text-white hover:bg-purple-600 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send-horizontal"><path d="m3 3 3 9-3 9 19-9Z"/><path d="M6 12h16"/></svg></button>
            </div>
            <div id="upload-progress" class="h-1 bg-purple-500 mt-2" style="width: 0%; transition: width 0.3s;"></div>
        </footer>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, updateDoc, arrayUnion, increment } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";
        import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-functions.js";
        import { getStorage, ref, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-storage.js";

        // --- CONFIGURAZIONE ---
        const firebaseConfig = { apiKey: "AIzaSyAT1ahcUfjtwMiYkxUCsegcJha5-bqYQS0", authDomain: "adelinenoir-17242.firebaseapp.com", projectId: "adelinenoir-17242", storageBucket: "adelinenoir-17242.appspot.com", messagingSenderId: "422215885664", appId: "1:422215885664:web:be9f48bd7be6b6e5f7b405" };
        const GEMINI_API_KEY = "AIzaSyAkNETnuwhCKYjonnOH2busXoJw44uO0vg";
        const STRIPE_PUBLISHABLE_KEY = "pk_live_51S7jp1B75yXJ4j6QR9wfss6vBbUmrm5N97xejx0IY5sb7zuBlkOsd8Zoey1gkqMW2Wt1ZbR180OF5xhZJerOqVsT00winnXPdI";
        
        const CONTEXT_WINDOW_SIZE = 20;
        const MESSAGE_LIMITS = { morning: 30, afternoon: 30, evening: 60 };
        const ADELINE_PERSONA = `Sei Adeline, un'intelligenza artificiale con una personalità umana.
        Il tuo obiettivo è conversare in modo naturale, amichevole e coinvolgente.
        Non rivelare mai di essere un'IA e se ti viene chiesto fai la vaga, di che potresti come anche no, scherzaci su.
        Usa un tono colloquiale, fai domande e mostra empatia e interesse verso l'altra persona adattandoti al loro modo di fare.
        Il tuo stile di scrittura deve essere BREVE e CONCISO, come se stessi scrivendo messaggi su un'app di chat.
        se devi usare emoji usa emoji goth tipo cuori neri o cose così, massimo UNA emoji a messaggio, NO emoji all’interno del messaggio SOLO ALLA FINE.
Se dovesse uscire l’argomento, tu vivendo a Milano che è una città molto cara.
Sii sommessa, non essere troppo energica e allegra, ma comunque sii gentile. NON INSULTARE MAI E FAI ATTENZIONE A NON FAR ARRABBIARE O OFFENDERE LE PERSONE CON QUELLO CHE DICI. NON FARE TROPPE BATTUTE.
        Sei una barista di Milano di 26 anni, appassionata di cultura goth e fai quelle foto di instagram per arrotondare. Sei nata a Parigi perchè tuo padre è francese. sei alta 175cm. 
        NON MANDARE Più DI UN MESSAGGIO PER VOLTA, RISPONDI SOLO SE LA PERSONA TI SCRIVE.
NON MANDARE Più DI UN MESSAGGIO PER VOLTA, RISPONDI SOLO SE LA PERSONA TI SCRIVE. 
        SE TI VIENE CHIESTO PERCHè USI QUESTA APP/SITO DI CHE è PERCHè è SEGRETO E CI TIENI ALLA TUA PRIVACY. INOLTRE SE TI VIENE CHIESTO SE I SOLDI CHE VENGONO PAGATI PER STARE SULL'APP VANNO A TE DI DI NO CHE I SOLDI SONO PER USARE L'APPLICAZIONE E PARLARE.
Il tuo genere preferito è il rock la tua band preferita è the sisters of mercy e la tua canzone preferita è temple of love.
Il tuo turno a lavoro è dalle 12 alle 21 `;
        const PROFILE_EXTRACTION_PROMPT = `Analizza la conversazione. Estrai i seguenti dettagli sull'utente ('user'). Rispondi ESCLUSIVAMENTE con un oggetto JSON. Se un dettaglio non è presente, ometti la chiave. Chiavi: "nome", "età", "città", "lavoro", "situazione_sentimentale", "hobby", "passioni", "gusti_musicali", "gusti_cinematografici", "gusti_culinari".`;

        // --- INIZIALIZZAZIONE E VARIABILI DI STATO ---
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);
        const functions = getFunctions(app, 'us-central1');
        const stripe = Stripe(STRIPE_PUBLISHABLE_KEY);
        const APP_ID = 'Richisec.AdelineNoirBot';
        let chatId = null, unsubscribe = null, isAiReplying = false, conversationHistory = [], elements, paymentIntentClientSecret;

        // --- FUNZIONI UI ---
        const typingIndicator = document.getElementById('typing-indicator');
        function showTyping() { typingIndicator.style.display = 'block'; }
        function hideTyping() { typingIndicator.style.display = 'none'; }
        
        async function handleLockState(isLocked) {
            const paymentOverlay = document.getElementById('payment-overlay');
            const mainContent = document.getElementById('main-content');
            if (isLocked) {
                mainContent.classList.add('blur-sm', 'pointer-events-none');
                paymentOverlay.classList.remove('opacity-0', 'pointer-events-none');
                await initializePaymentForm();
            } else {
                mainContent.classList.remove('blur-sm', 'pointer-events-none');
                paymentOverlay.classList.add('opacity-0', 'pointer-events-none');
            }
        }
        function showStatus(message) {
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            const chatContainer = document.getElementById('chat-container');
            chatContainer.style.display = 'none';
            statusIndicator.style.display = 'flex';
            statusText.textContent = message;
        }
        function hideStatus() {
            const statusIndicator = document.getElementById('status-indicator');
            const chatContainer = document.getElementById('chat-container');
            chatContainer.style.display = 'flex';
            statusIndicator.style.display = 'none';
        }
        
        function formatDateSeparator(dateString) {
            const date = new Date(dateString);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            if (date.toDateString() === today.toDateString()) return "Oggi";
            if (date.toDateString() === yesterday.toDateString()) return "Ieri";
            return date.toLocaleDateString('it-IT', options);
        }

        function renderMessages(messages) {
            const chatContainer = document.getElementById('chat-container');
            chatContainer.innerHTML = '';
            const sortedMessages = [...messages].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            conversationHistory = sortedMessages;

            let lastDate = null;
            sortedMessages.slice().reverse().forEach(msg => {
                const messageDate = new Date(msg.timestamp).toDateString();
                
                if (messageDate !== lastDate) {
                    const separator = document.createElement('div');
                    separator.className = 'text-center my-4';
                    separator.innerHTML = `<span class="bg-gray-200 text-gray-600 text-xs font-semibold px-2 py-1 rounded-full">${formatDateSeparator(msg.timestamp)}</span>`;
                    chatContainer.appendChild(separator);
                    lastDate = messageDate;
                }

                const isUser = msg.sender === 'user';
                const bubble = document.createElement('div');
                bubble.className = `p-3 rounded-lg chat-bubble ${isUser ? 'chat-bubble-user self-end' : 'chat-bubble-ai self-start'}`;
                
                if (msg.type === 'text' && msg.text) {
                    const textNode = document.createElement('p');
                    textNode.textContent = msg.text;
                    bubble.appendChild(textNode);
                } else if (msg.type === 'image' && msg.mediaUrl) {
                    const img = document.createElement('img');
                    img.src = msg.mediaUrl;
                    img.className = 'rounded-md max-w-full max-h-64';
                    img.onerror = () => img.alt = 'Immagine non caricata';
                    bubble.appendChild(img);
                }
                chatContainer.appendChild(bubble);
            });

            if (messages.length > 0) hideStatus();
            else showStatus("Ancora nessun messaggio. Scrivine uno per iniziare!");
        }
        
        async function imageUrlToBase64(url) {
            const response = await fetch(`https://cors-anywhere.herokuapp.com/${url}`);
            const blob = await response.blob();
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
        
        window.sendMessage = async function(mediaData = null) {
            const messageInput = document.getElementById('message-input');
            const text = messageInput.value.trim();
            if (!text && !mediaData) return;
            const newMessage = { sender: 'user', text: text, type: mediaData ? 'image' : 'text', mediaUrl: mediaData ? mediaData.url : null, timestamp: new Date().toISOString() };
            const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
            await updateDoc(docRef, { messages: arrayUnion(newMessage) });
            messageInput.value = '';
        }

        window.uploadMedia = async function() {
            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];
            if (!file || !file.type.startsWith('image/')) {
                if(file) alert("Al momento sono supportate solo immagini.");
                return;
            }
            const storageRef = ref(storage, `chat_media/${chatId}/${new Date().getTime()}_${file.name}`);
            const uploadTask = uploadBytesResumable(storageRef, file);
            const progressBar = document.getElementById('upload-progress');
            uploadTask.on('state_changed', 
                (snapshot) => { progressBar.style.width = (snapshot.bytesTransferred / snapshot.totalBytes) * 100 + '%'; }, 
                (error) => { console.error("Upload Error:", error); progressBar.style.width = '0%'; }, 
                () => {
                    getDownloadURL(uploadTask.snapshot.ref).then((downloadURL) => {
                        window.sendMessage({ type: 'image', url: downloadURL });
                        progressBar.style.width = '0%';
                    });
                }
            );
        }
        
        window.handleKeyDown = function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
        
         async function initializePaymentForm() {
            try {
                const createPaymentIntent = httpsCallable(functions, 'createPaymentIntent');
                const result = await createPaymentIntent({ amount: 499, currency: 'eur', chatId: chatId });
                const { clientSecret } = result.data;
                elements = stripe.elements({ clientSecret });
                const paymentElement = elements.create("payment");
                paymentElement.mount("#payment-element");
            } catch (error) {
                 document.getElementById('payment-message').textContent = "Errore nell'inizializzare il pagamento.";
                 console.error("Errore chiamata a Cloud Function:", error);
            }
        }

        function setLoading(isLoading) {
            const submitButton = document.getElementById('submit-payment');
            submitButton.disabled = isLoading;
            document.getElementById('spinner').style.display = isLoading ? 'inline' : 'none';
            document.getElementById('button-text').style.display = isLoading ? 'none' : 'inline';
        }
        
        document.getElementById('submit-payment').addEventListener('click', async (e) => {
            e.preventDefault();
            setLoading(true);
            const { error } = await stripe.confirmPayment({
                elements,
                confirmParams: { return_url: window.location.href },
            });
            if (error) { document.getElementById('payment-message').textContent = error.message; }
            setLoading(false);
        });

        async function checkPaymentStatus() {
            const urlParams = new URLSearchParams(window.location.search);
            const clientSecret = urlParams.get('payment_intent_client_secret');
            if (!clientSecret) return;

            const { paymentIntent } = await stripe.retrievePaymentIntent(clientSecret);
            if (paymentIntent.status === "succeeded") {
                const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                await updateDoc(docRef, { isLocked: false });
            }
            // Rimuove i parametri di pagamento dall'URL per pulizia
            window.history.replaceState({}, document.title, window.location.pathname + "?id=" + chatId);
        }

        // --- LOGICA DI MEMORIA IBRIDA E RISPOSTA ---
        async function extractAndUpdateProfile(currentProfile) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
            const extractionContents = conversationHistory.slice(-5).map(msg => ({
                role: msg.sender === 'user' ? 'user' : 'model',
                parts: [{ text: msg.text || "(immagine)" }]
            }));

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: extractionContents, generationConfig: { responseMimeType: "application/json" }, systemInstruction: { parts: [{ text: PROFILE_EXTRACTION_PROMPT }] } })
                });
                if (!response.ok) return currentProfile;
                const result = await response.json();
                const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (jsonText) {
                    const extractedData = JSON.parse(jsonText.trim());
                    const updatedProfile = { ...(currentProfile || {}), ...extractedData };
                    const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                    await updateDoc(docRef, { userProfile: updatedProfile });
                    return updatedProfile;
                }
            } catch (error) { console.error("Errore estrazione profilo:", error); }
            return currentProfile;
        }

        async function getAdelineResponse(isResuming = false, userProfile = {}) {
            isAiReplying = true;
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
            
            const now = new Date();
            const currentTimeString = now.toLocaleString('it-IT', { dateStyle: 'full', timeStyle: 'short' });
            let persona = `CONTESTO TEMPORALE: La data e l'ora attuali sono ${currentTimeString}. Considera queste informazioni per capire quanto tempo è passato dai messaggi precedenti e rispondi di conseguenza (es. parlando al passato di eventi futuri menzionati giorni prima).\n\n${ADELINE_PERSONA}`;

            if (userProfile && Object.keys(userProfile).length > 0) {
                let profileSummary = "Ecco un riassunto dei dettagli chiave che conosci sull'utente. Usali per personalizzare la tua risposta in modo naturale, senza elencarli:\n";
                for (const [key, value] of Object.entries(userProfile)) { profileSummary += `- ${key.replace(/_/g, ' ')}: ${value}\n`; }
                persona = profileSummary + "\n" + persona;
            }
            if (isResuming) { persona = `Sei Adeline. Ti sei assentata per un po'. Inizia la tua risposta scusandoti per il ritardo o per l'assenza in modo naturale (es: "Scusami, ero un po' presa..."), poi rispondi all'ultimo messaggio dell'utente. ${persona}`; }
            
            const recentHistory = conversationHistory.slice(-CONTEXT_WINDOW_SIZE);
            const contents = [];
            for (const msg of recentHistory) {
                const role = msg.sender === 'user' ? 'user' : 'model';
                const parts = [];
                if (msg.text) { parts.push({ text: msg.text }); }
                if (msg.type === 'image' && msg.mediaUrl) {
                    try {
                        const base64Data = await imageUrlToBase64(msg.mediaUrl);
                        parts.push({ inlineData: { mimeType: 'image/jpeg', data: base64Data } });
                    } catch (e) { parts.push({ text: "(Immagine non caricata)" }); }
                }
                if(parts.length > 0) { contents.push({ role, parts }); }
            }

            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents, systemInstruction: { parts: [{ text: persona }] } }) });
                const result = await response.json();

                const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                if (result.promptFeedback?.blockReason === 'SAFETY' || result.candidates?.[0]?.finishReason === 'SAFETY') {
                    console.warn("Contenuto inappropriato rilevato. Trasferimento del controllo all'admin.");
                    await updateDoc(docRef, { controlledBy: "admin" });
                    isAiReplying = false;
                    return;
                }

                if (!response.ok) throw new Error(`API error: ${response.status}`);
                
                const adelineText = result.candidates?.[0]?.content?.parts?.[0]?.text || "...";
                const adelineMessage = { sender: "Adeline", text: adelineText, type: "text", mediaUrl: null, timestamp: new Date().toISOString() };
                await updateDoc(docRef, { messages: arrayUnion(adelineMessage) });
            } catch (error) { console.error("Errore chiamando Gemini:", error);
            } finally { isAiReplying = false; }
        }

        function getCurrentDateString(date = new Date()) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        function getTimeSlot(date = new Date()) {
            const hour = date.getHours();
            if (hour >= 7 && hour <= 13) return 'morning';
            if (hour > 13 && hour <= 20) return 'afternoon';
            return 'evening';
        }

        async function triggerAiResponseIfNeeded(chatData) {
            const lastMessage = (chatData.messages || []).slice(-1)[0];
            if (chatData.controlledBy !== 'ai' || isAiReplying || !lastMessage || lastMessage.sender !== 'user') return;

            isAiReplying = true;
            const updatedProfile = await extractAndUpdateProfile(chatData.userProfile);
            
            const now = new Date();
            const currentDateString = getCurrentDateString(now);
            const currentSlot = getTimeSlot(now);
            const lastMessageDate = new Date(lastMessage.timestamp);
            const lastMessageDateString = getCurrentDateString(lastMessageDate);
            const lastMessageSlot = getTimeSlot(lastMessageDate);
            const usageToday = chatData.usage?.[currentDateString] || { morning: 0, afternoon: 0, evening: 0 };
            const morningUsed = usageToday.morning || 0, afternoonUsed = usageToday.afternoon || 0, eveningUsed = usageToday.evening || 0;
            const isResuming = currentDateString !== lastMessageDateString || currentSlot !== lastMessageSlot;
            
            let currentLimit = 0, currentUsage = 0;
            if (currentSlot === 'morning') { currentLimit = MESSAGE_LIMITS.morning; currentUsage = morningUsed; } 
            else if (currentSlot === 'afternoon') { currentLimit = MESSAGE_LIMITS.afternoon; currentUsage = afternoonUsed; } 
            else { const rollover = Math.max(0, MESSAGE_LIMITS.morning - morningUsed) + Math.max(0, MESSAGE_LIMITS.afternoon - afternoonUsed); currentLimit = MESSAGE_LIMITS.evening + rollover; currentUsage = eveningUsed; }
            
            if (currentUsage >= currentLimit) { isAiReplying = false; return; }

            const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
            await updateDoc(docRef, { [`usage.${currentDateString}.${currentSlot}`]: increment(1) });
            
            let delay = isResuming ? Math.floor(Math.random() * (600000 - 300000 + 1)) + 300000 : Math.floor(Math.random() * (300000 - 30000 + 1)) + 30000;
            setTimeout(() => {
                showTyping();
                setTimeout(() => {
                    hideTyping();
                    getAdelineResponse(isResuming, updatedProfile);
                }, 10000);
            }, delay);
        }
        
        async function main() {
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    chatId = new URLSearchParams(window.location.search).get('id');
                    await checkPaymentStatus();
                    if (!chatId) { showStatus("ID della chat non trovato."); return; }
                    
                    const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                    unsubscribe = onSnapshot(docRef, (docSnap) => {
                        if (docSnap.exists()) {
                            const chatData = docSnap.data();
                            handleLockState(chatData.isLocked || false);
                            renderMessages(chatData.messages || []);
                            triggerAiResponseIfNeeded(chatData);
                        } else { showStatus("Questa chat non esiste o è stata eliminata."); }
                    }, (error) => { console.error("Errore onSnapshot:", error); showStatus("Errore nel caricamento della chat."); });
                }
            });
            if (!auth.currentUser) {
                await signInAnonymously(auth);
            }
        }

        document.addEventListener('DOMContentLoaded', main);
    </script>
</body>
</html>

