<!DOCTYPE html>
<html lang="it" class="h-full bg-gray-100">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adeline Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://js.stripe.com/v3/"></script> <!-- SDK di Stripe -->
    <style>
        body { font-family: 'Inter', sans-serif; }
        .chat-bubble { max-width: 75%; }
        .chat-bubble-user { background-color: #3b82f6; color: white; }
        .chat-bubble-ai { background-color: #e5e7eb; color: #1f2937; }
        #chat-container { display: flex; flex-direction: column-reverse; overflow-y: auto; flex-grow: 1; }
        #payment-overlay { transition: opacity 0.3s ease-in-out; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="h-full flex flex-col relative">

    <!-- Schermata di Pagamento (nascosta di default) -->
    <div id="payment-overlay" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50 opacity-0 pointer-events-none">
        <div class="bg-white rounded-lg shadow-xl p-8 max-w-sm w-full text-center">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Chat Interrotta</h2>
            <p class="text-gray-600 mb-6">Funzionalità Premium terminata, continua per riaprire la chat</p>
            <div id="payment-element" class="mb-6"></div>
            <button id="submit-payment" class="w-full bg-purple-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-purple-700 transition-colors disabled:bg-gray-400">
                <span id="button-text">Paga ora 4,99€</span>
                <span id="spinner" class="hidden">Elaborazione...</span>
            </button>
            <p id="payment-message" class="text-sm text-red-500 mt-4"></p>
        </div>
    </div>

    <!-- Contenuto principale della chat -->
    <div id="main-content" class="h-full flex flex-col">
        <header class="bg-white shadow-md p-4 flex items-center space-x-4 z-10">
            <div class="w-12 h-12 rounded-full bg-purple-500 flex items-center justify-center text-white text-xl font-bold">A</div>
            <div><h1 class="text-xl font-bold text-gray-800">Adeline</h1></div>
        </header>
        <main id="chat-container" class="p-4 space-y-4"></main>
        <div id="status-indicator" class="flex-grow flex items-center justify-center">
            <p id="status-text" class="text-gray-500 text-center p-4">Caricamento della chat...</p>
        </div>
        <div id="typing-indicator" class="p-4 hidden"><p class="text-gray-500 italic">Adeline sta scrivendo...</p></div>
        <footer class="bg-white p-4 border-t border-gray-200">
            <div class="flex items-center space-x-2">
                <input type="file" id="file-input" class="hidden" accept="image/*,video/*" onchange="uploadMedia()">
                <button onclick="document.getElementById('file-input').click()" class="p-3 rounded-full hover:bg-gray-200 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-600"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg></button>
                <input type="text" id="message-input" placeholder="Scrivi un messaggio..." class="flex-grow p-3 border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-purple-500" onkeydown="handleKeyDown(event)">
                <button id="send-button" onclick="sendMessage()" class="p-3 rounded-full bg-purple-500 text-white hover:bg-purple-600 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send-horizontal"><path d="m3 3 3 9-3 9 19-9Z"/><path d="M6 12h16"/></svg></button>
            </div>
            <div id="upload-progress" class="h-1 bg-purple-500 mt-2" style="width: 0%; transition: width 0.3s;"></div>
        </footer>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, updateDoc, arrayUnion } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-storage.js";

        const firebaseConfig = { apiKey: "AIzaSyAT1ahcUfjtwMiYkxUCsegcJha5-bqYQS0", authDomain: "adelinenoir-17242.firebaseapp.com", projectId: "adelinenoir-17242", storageBucket: "adelinenoir-17242.appspot.com", messagingSenderId: "422215885664", appId: "1:422215885664:web:be9f48bd7be6b6e5f7b405" };
        const GEMINI_API_KEY = "AIzaSyAkNETnuwhCKYjonnOH2busXoJw44uO0vg";
        const STRIPE_PUBLISHABLE_KEY = "pk_live_51S7jp1B75yXJ4j6QR9wfss6vBbUmrm5N97xejx0IY5sb7zuBlkOsd8Zoey1gkqMW2Wt1ZbR180OF5xhZJerOqVsT00winnXPdI"; 
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);
        const stripe = Stripe(STRIPE_PUBLISHABLE_KEY);

        const APP_ID = 'Richisec.AdelineNoirBot';
        let chatId = null;
        let unsubscribe = null;
        let isAiReplying = false;
        let conversationHistory = [];
        let elements, paymentIntentClientSecret;

        const ADELINE_PERSONA = `Sei Adeline, un'intelligenza artificiale con una personalità umana.
        Il tuo obiettivo è conversare in modo naturale, amichevole e coinvolgente.
        Non rivelare mai di essere un'IA e se ti viene chiesto fai la vaga, di che potresti come anche no, scherzaci su.
        Usa un tono colloquiale, fai domande e mostra empatia e interesse verso l'altra persona adattandoti al loro modo di fare.
        Il tuo stile di scrittura deve essere BREVE e CONCISO, come se stessi scrivendo messaggi su un'app di chat.
        se devi usare emoji usa emoji goth tipo cuori neri o cose così, massimo UNA emoji a messaggio, NO emoji all’interno del messaggio SOLO ALLA FINE.
Se dovesse uscire l’argomento, tu vivendo a Milano che è una città molto cara, fai queste foto e fai compagnia ANCHE per arrotondare e che ti fa piacere l’aiuto della persona con cui parli.
Sii sommessa, non essere troppo energica e allegra, ma comunque sii gentile. NON INSULTARE MAI E FAI ATTENZIONE A NON FAR ARRABBIARE O OFFENDERE LE PERSONE CON QUELLO CHE DICI. NON FARE TROPPE BATTUTE.
        Sei una barista di Milano di 26 anni, appassionata di cultura goth e fai quelle foto di instagram per arrotondare. Sei nata a Parigi perchè tuo padre è francese. sei alta 175cm. 
        NON MANDARE Più DI UN MESSAGGIO PER VOLTA, RISPONDI SOLO SE LA PERSONA TI SCRIVE.`;

        const typingIndicator = document.getElementById('typing-indicator');
        const paymentOverlay = document.getElementById('payment-overlay');
        const mainContent = document.getElementById('main-content');
        
        function showTyping() { typingIndicator.style.display = 'block'; }
        function hideTyping() { typingIndicator.style.display = 'none'; }
        
        async function handleLockState(isLocked) {
            if (isLocked) {
                mainContent.classList.add('blur-sm', 'pointer-events-none');
                paymentOverlay.classList.remove('opacity-0', 'pointer-events-none');
                await initializePaymentForm();
            } else {
                mainContent.classList.remove('blur-sm', 'pointer-events-none');
                paymentOverlay.classList.add('opacity-0', 'pointer-events-none');
            }
        }
        
        function showStatus(message) {
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            const chatContainer = document.getElementById('chat-container');
            chatContainer.style.display = 'none';
            statusIndicator.style.display = 'flex';
            statusText.textContent = message;
        }

        function hideStatus() {
            const statusIndicator = document.getElementById('status-indicator');
            const chatContainer = document.getElementById('chat-container');
            chatContainer.style.display = 'flex';
            statusIndicator.style.display = 'none';
        }

        function renderMessages(messages) {
             const chatContainer = document.getElementById('chat-container');
            chatContainer.innerHTML = '';
            const sortedMessages = [...messages].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            conversationHistory = sortedMessages;

            sortedMessages.slice().reverse().forEach(msg => {
                const isUser = msg.sender === 'user';
                const bubble = document.createElement('div');
                bubble.className = `p-3 rounded-lg chat-bubble ${isUser ? 'chat-bubble-user self-end' : 'chat-bubble-ai self-start'}`;

                if (msg.type === 'text' && msg.text) {
                    const textNode = document.createElement('p');
                    textNode.textContent = msg.text;
                    bubble.appendChild(textNode);
                }
                chatContainer.appendChild(bubble);
            });

            if (messages.length > 0) hideStatus();
            else showStatus("Ancora nessun messaggio. Scrivine uno per iniziare!");
        }

        async function getAdelineResponse(retries = 3, delay = 1000) {
             isAiReplying = true;
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
            const latestMessages = conversationHistory.map(msg => ({ role: msg.sender === 'user' ? 'user' : 'model', parts: [{ text: msg.text || "Media inviato" }] }));

            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: latestMessages, systemInstruction: { parts: [{ text: ADELINE_PERSONA }] } }) });
                if (response.status >= 500 && retries > 0) {
                    await new Promise(res => setTimeout(res, delay));
                    return getAdelineResponse(retries - 1, delay * 2);
                }
                if (!response.ok) { throw new Error(`API error: ${response.status}`); }
                const result = await response.json();
                const adelineText = result.candidates?.[0]?.content?.parts?.[0]?.text || "Non so cosa dire.";
                const adelineMessage = { sender: "Adeline", text: adelineText, type: "text", mediaUrl: null, timestamp: new Date().toISOString() };
                const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                await updateDoc(docRef, { messages: arrayUnion(adelineMessage) });
            } catch (error) {
                console.error("Errore chiamando Gemini:", error);
            } finally {
                isAiReplying = false;
            }
        }

        async function initializePaymentForm() {
            try {
                const CLOUD_FUNCTION_URL = "https://us-central1-adelinenoir-17242.cloudfunctions.net/createPaymentIntent";
                const response = await fetch(CLOUD_FUNCTION_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ amount: 499, currency: 'eur' }) });
                const { clientSecret } = await response.json();
                elements = stripe.elements({ clientSecret });
                const paymentElement = elements.create("payment");
                paymentElement.mount("#payment-element");
            } catch (error) {
                 document.getElementById('payment-message').textContent = "Errore nell'inizializzare il pagamento.";
            }
        }

        function setLoading(isLoading) {
            const submitButton = document.getElementById('submit-payment');
            if (isLoading) {
                submitButton.disabled = true;
                document.getElementById('spinner').style.display = 'inline';
                document.getElementById('button-text').style.display = 'none';
            } else {
                submitButton.disabled = false;
                document.getElementById('spinner').style.display = 'none';
                document.getElementById('button-text').style.display = 'inline';
            }
        }

        document.getElementById('submit-payment').addEventListener('click', async (e) => {
            e.preventDefault();
            setLoading(true);

            // Salva il chatId prima del reindirizzamento
            sessionStorage.setItem('chatIdForPayment', chatId);

            const { error } = await stripe.confirmPayment({
                elements,
                confirmParams: {
                    // Reindirizza alla pagina base, ricostruiremo l'URL dopo
                    return_url: window.location.href.split('?')[0],
                },
            });
            
            if (error && (error.type === "card_error" || error.type === "validation_error")) {
                document.getElementById('payment-message').textContent = error.message;
            } else if (error) {
                document.getElementById('payment-message').textContent = "Si è verificato un errore inaspettato.";
            }
            setLoading(false);
        });
        
        // NUOVA FUNZIONE: Controlla lo stato del pagamento al ritorno da Stripe
        async function checkPaymentStatus() {
            const urlParams = new URLSearchParams(window.location.search);
            const clientSecret = urlParams.get('payment_intent_client_secret');
            
            // Prova a recuperare il chatId dalla sessione se non è nell'URL
            const storedChatId = sessionStorage.getItem('chatIdForPayment');

            if (!clientSecret || !storedChatId) {
                return; // Nessun pagamento da controllare
            }

            const { paymentIntent } = await stripe.retrievePaymentIntent(clientSecret);

            switch (paymentIntent.status) {
                case "succeeded":
                    console.log("Pagamento riuscito! Sblocco la chat.");
                    const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", storedChatId);
                    await updateDoc(docRef, { isLocked: false });
                    sessionStorage.removeItem('chatIdForPayment'); // Pulisce la sessione
                    // Reindirizza all'URL corretto della chat per ricaricare
                    window.location.href = window.location.pathname + '?id=' + storedChatId;
                    break;
                default:
                    // Se il pagamento non è riuscito, ricarica comunque la chat per mostrare il paywall
                    window.location.href = window.location.pathname + '?id=' + storedChatId;
                    break;
            }
        }

        async function main() {
            try {
                await signInAnonymously(auth);
                
                // Controlla subito se siamo di ritorno da un pagamento
                await checkPaymentStatus();
                
                const urlParams = new URLSearchParams(window.location.search);
                chatId = urlParams.get('id');
                if (!chatId) { 
                    showStatus("ID della chat non trovato."); 
                    return; 
                }

                const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
                unsubscribe = onSnapshot(docRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const chatData = docSnap.data();
                        handleLockState(chatData.isLocked || false);
                        renderMessages(chatData.messages || []);
                        const lastMessage = (chatData.messages || []).slice(-1)[0];
                        
                        if (chatData.controlledBy === 'ai' && !isAiReplying && lastMessage && lastMessage.sender === 'user') {
                            const randomDelay = Math.floor(Math.random() * (300000 - 30000 + 1)) + 30000;
                            setTimeout(() => {
                                showTyping();
                                setTimeout(() => {
                                    hideTyping();
                                    getAdelineResponse();
                                }, 10000);
                            }, randomDelay);
                        }
                    } else { showStatus("Questa chat non esiste o è stata eliminata."); }
                });
            } catch (error) { console.error("Errore:", error); showStatus("Impossibile connettersi."); }
        }

        document.addEventListener('DOMContentLoaded', main);
        
        window.sendMessage = async function(mediaData = null) {
            const messageInput = document.getElementById('message-input');
            const text = messageInput.value.trim();
            if (!text && !mediaData) return;
            const newMessage = { sender: 'user', text: text, type: 'text', mediaUrl: null, timestamp: new Date().toISOString() };
            const docRef = doc(db, "artifacts", APP_ID, "public", "data", "chats", chatId);
            await updateDoc(docRef, { messages: arrayUnion(newMessage) });
            messageInput.value = '';
        }
        
        window.uploadMedia = function() { /* Inserire qui la logica di upload */ }
        window.handleKeyDown = function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
    </script>
</body>
</html>

